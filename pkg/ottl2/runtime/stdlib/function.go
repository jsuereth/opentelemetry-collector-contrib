// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package stdlib // import "github.com/open-telemetry/opentelemetry-collector-contrib/pkg/ottl2/runtime/stdlib"

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"

	"github.com/open-telemetry/opentelemetry-collector-contrib/pkg/ottl2/runtime"
	"go.opentelemetry.io/collector/pdata/pcommon"
) // This type does not support named args.
type simpleFunc struct {
	name    string
	numArgs int
	f       func([]runtime.Val) runtime.Val
}

// Name implements Function.
func (f *simpleFunc) Name() string {
	return f.name
}

// ArgNames implements Function.
func (f *simpleFunc) ArgNames() []string {
	return make([]string, f.numArgs)
}

// DefaultArgs implements Function.
func (f *simpleFunc) DefaultArgs() map[string]runtime.Val {
	return map[string]runtime.Val{}
}

func (f *simpleFunc) Call(args []runtime.Val) runtime.Val {
	return f.f(args)
}

func NewSimpleFunc(name string, numArgs int, f func([]runtime.Val) runtime.Val) runtime.Function {
	return &simpleFunc{name, numArgs, f}
}

type advancedFunction struct {
	name        string
	argNames    []string
	defaultArgs map[string]runtime.Val
	f           func([]runtime.Val) runtime.Val
}

// Name implements Function.
func (a advancedFunction) Name() string {
	return a.name
}

// ArgNames implements Function.
func (a advancedFunction) ArgNames() []string {
	return a.argNames
}

// Call implements Function.
func (a advancedFunction) Call(args []runtime.Val) runtime.Val {
	return a.f(args)
}

// DefaultArgs implements Function.
func (a advancedFunction) DefaultArgs() map[string]runtime.Val {
	return a.defaultArgs
}

// Constructs a function that can have named or default parameters.
func NewFunc(
	// Name of the function.
	name string,
	// Names of argument values.  Empty strings denote positional only args.
	argNames []string,
	// Default arguments. Must be used with named parameters.
	defaultArgs map[string]runtime.Val,
	// A positional-only implementation of the function.
	// All named/default arguments will be turned positional using argNames before calling this.
	f func([]runtime.Val) runtime.Val,
) runtime.Function {
	// TODO - verify named arguments exist in argument list.
	return advancedFunction{name, argNames, defaultArgs, f}
}

// A function where the arguments is a structure.
type reflectArgsFunc[T any] struct {
	// Name is the canonical name to be used by the user when invocating
	// the function generated by this Factory.
	name string
	// Initial argument struct, specific to this function.
	args *T
	// The implementation of the function.
	impl func(*T) runtime.Val
	// Argument names (pulled reflectively).
	argNames []string
	// Default argument values (pulled reflectively).
	defaultValues map[string]runtime.Val
}

// ArgNames implements types.Function.
func (r *reflectArgsFunc[T]) ArgNames() []string {
	return r.argNames
}

// Call implements types.Function.
func (r *reflectArgsFunc[T]) Call(args []runtime.Val) runtime.Val {
	var rArgs any = reflect.New(reflect.ValueOf(r.args).Elem().Type()).Interface()
	argsVal := reflect.ValueOf(rArgs).Elem()
	for i := 0; i < argsVal.NumField(); i++ {
		field := argsVal.Field(i)
		fieldType := field.Type()
		if fieldType == reflect.TypeFor[runtime.Val]() {
			field.Set(reflect.ValueOf(args[i]))
		} else if fieldType == reflect.TypeFor[runtime.Var]() {
			field.Set(reflect.ValueOf(args[i]))
		} else {
			// If argument isn't a "Val", we call the .Value.
			v := args[i].Value()
			// If the argument is empty, we don't try to set the arugment value.
			if v != nil {
				field.Set(reflect.ValueOf(v))
			}
		}
	}
	return r.impl(rArgs.(*T))
}

// DefaultArgs implements types.Function.
func (r *reflectArgsFunc[T]) DefaultArgs() map[string]runtime.Val {
	return r.defaultValues
}

// Name implements types.Function.
func (r *reflectArgsFunc[T]) Name() string {
	return r.name
}

// Constructs a new function that leverages a structure for all arguments.
//
//   - args MUST be a pointer to a structure.
//   - The name of fields in the structure become the name of allowed arguments to
//     the function.
//   - Fields can be annotated with tags `ottl:` to denote default values.
func NewReflectFunc[T any](
	name string,
	args *T,
	impl func(*T) runtime.Val,
) runtime.Function {
	if reflect.TypeOf(args).Kind() != reflect.Pointer {
		// TODO - non-panic error.
		panic(fmt.Sprintf("factory for %s must return pointer to Arguments", name))
	}
	// Here we construct default arguments for parsing.
	argsVal := reflect.ValueOf(args).Elem()
	argNames := []string{}
	defaultArgs := map[string]runtime.Val{}
	for i := 0; i < argsVal.NumField(); i++ {
		argNames = append(argNames, argsVal.Type().Field(i).Name)
		if defaultValue, ok := parseOttlArgTag(argsVal.Type().Field(i)); ok {
			defaultArgs[argsVal.Type().Field(i).Name] = defaultValue
		}
	}
	return &reflectArgsFunc[T]{name, args, impl, argNames, defaultArgs}
}

// Parses `ottl` tag on argument structure fields.
func parseOttlArgTag(field reflect.StructField) (runtime.Val, bool) {
	tag := field.Tag.Get("ottl")
	// TODO - parse out field tags.
	if tag != "" {
		// parse key-value pairs
		options := make(map[string]string)
		parts := strings.Split(tag, ",")
		for _, part := range parts {
			kv := strings.Split(part, "=")
			if len(kv) == 2 {
				options[kv[0]] = kv[1]
			}
		}
		if defaultStr, ok := options["default"]; ok {
			// We need to translate this to the right value...
			switch field.Type.Kind() {
			case reflect.Struct:
				switch defaultStr {
				case "pcommon.Slice()":
					return NewSliceVar(pcommon.NewSlice()), true
				}
				panic(fmt.Sprintf("ottl setup error: invalid default value for struct field %s: %v", field.Name, defaultStr))
			case reflect.Interface:
				if defaultStr == "nil" {
					return NilVal, true
				}
				panic(fmt.Sprintf("ottl setup error: invalid default value for interface field %s: %v", field.Name, defaultStr))
			case reflect.String:
				return NewStringVal(defaultStr), true
			case reflect.Int | reflect.Int64:
				val, err := strconv.Atoi(defaultStr)
				if err != nil {
					panic(fmt.Sprintf("ottl setup error: invalid default value for int field %s: %v", field.Name, err))
				}
				return NewIntVal(int64(val)), true
			case reflect.Bool:
				val, err := strconv.ParseBool(defaultStr)
				if err != nil {
					panic(fmt.Sprintf("ottl setup error: invalid default value for bool field %s: %v", field.Name, err))
				}
				return NewBoolVal(val), true
			default:
				panic(fmt.Sprintf("ottl setup error: unsupported type for default value: %s", field.Type.Kind()))
			}
		}
	}

	return nil, false
}
