// Copyright The OpenTelemetry Authors
// SPDX-License-Identifier: Apache-2.0

package stdlib // import "github.com/open-telemetry/opentelemetry-collector-contrib/pkg/ottl2/types/stdlib"

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/open-telemetry/opentelemetry-collector-contrib/pkg/ottl2/types"
) // This type does not support named args.
type simpleFunc struct {
	name    string
	numArgs int
	f       func([]types.Val) types.Val
}

// Name implements Function.
func (f *simpleFunc) Name() string {
	return f.name
}

// ArgNames implements Function.
func (f *simpleFunc) ArgNames() []string {
	return make([]string, f.numArgs)
}

// DefaultArgs implements Function.
func (f *simpleFunc) DefaultArgs() map[string]types.Val {
	return map[string]types.Val{}
}

func (f *simpleFunc) Call(args []types.Val) types.Val {
	return f.f(args)
}

func NewSimpleFunc(name string, numArgs int, f func([]types.Val) types.Val) types.Function {
	return &simpleFunc{name, numArgs, f}
}

type advancedFunction struct {
	name        string
	argNames    []string
	defaultArgs map[string]types.Val
	f           func([]types.Val) types.Val
}

// Name implements Function.
func (a advancedFunction) Name() string {
	return a.name
}

// ArgNames implements Function.
func (a advancedFunction) ArgNames() []string {
	return a.argNames
}

// Call implements Function.
func (a advancedFunction) Call(args []types.Val) types.Val {
	return a.f(args)
}

// DefaultArgs implements Function.
func (a advancedFunction) DefaultArgs() map[string]types.Val {
	return a.defaultArgs
}

// Constructs a function that can have named or default parameters.
func NewFunc(
	// Name of the function.
	name string,
	// Names of argument values.  Empty strings denote positional only args.
	argNames []string,
	// Default arguments. Must be used with named parameters.
	defaultArgs map[string]types.Val,
	// A positional-only implementation of the function.
	// All named/default arguments will be turned positional using argNames before calling this.
	f func([]types.Val) types.Val,
) types.Function {
	// TODO - verify named arguments exist in argument list.
	return advancedFunction{name, argNames, defaultArgs, f}
}

// Arguments holds the arguments for an OTTL function, with arguments
// specified as fields on a struct. Argument ordering is defined
type Arguments any

// A function where the arguments is a structure.
type reflectArgsFunc struct {
	// Name is the canonical name to be used by the user when invocating
	// the function generated by this Factory.
	name string
	// Initial argument struct, specific to this function.
	args Arguments
	// The implementation of the function.
	impl func(Arguments) types.Val
}

// ArgNames implements types.Function.
func (r *reflectArgsFunc) ArgNames() []string {
	argsVal := reflect.ValueOf(r.args).Elem()
	result := []string{}
	for i := 0; i < argsVal.NumField(); i++ {
		result = append(result, argsVal.Type().Field(i).Name)
	}
	return result
}

// Call implements types.Function.
func (r *reflectArgsFunc) Call(args []types.Val) types.Val {
	var rArgs Arguments = reflect.New(reflect.ValueOf(r.args).Elem().Type()).Interface()
	argsVal := reflect.ValueOf(rArgs).Elem()
	for i := 0; i < argsVal.NumField(); i++ {
		field := argsVal.Field(i)
		fieldType := field.Type()
		isOptional := strings.HasPrefix(fieldType.Name(), "Optional")
		if isOptional {
			// TODO - use optional type handling.
		} else {
			field.Set(reflect.ValueOf(args[i].Value()))
		}
	}
	return r.impl(rArgs)
}

// DefaultArgs implements types.Function.
func (r *reflectArgsFunc) DefaultArgs() map[string]types.Val {
	// TODO - implement default arguments.
	return map[string]types.Val{}
}

// Name implements types.Function.
func (r *reflectArgsFunc) Name() string {
	return r.name
}

func NewReflectFunc(
	name string,
	args Arguments,
	impl func(Arguments) types.Val,
) types.Function {
	if reflect.TypeOf(args).Kind() != reflect.Pointer {
		// TODO - non-panic error.
		panic(fmt.Sprintf("factory for %s must return pointer to Arguments", name))
	}

	return &reflectArgsFunc{name, args, impl}
}
